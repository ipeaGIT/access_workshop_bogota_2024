{
  "hash": "a2440dc915d124cb83365d6b670b41c7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Flexible approach\"\ncode-annotations: hover\n---\n\n\n\n\nIn the the previous section, we learned a 'quick approach' to calculate accessibility directly from within `{r5r}`. The shortcoming of this approach it that is limited to only a few predefined accessibility metrics available in `{r5r}`. Oftentimes, we want to analyze other types of accessibility metrics and/or to have more control of the different steps of the analysis.\n\nIn this section, we'll learn how to calculate a travel time matrix and how to use it to compute different types of accessibility metrics. This is a more 'flexible' approach that combines the capabilities of the `{r5r}` and the `{accessibility}` packages. We'll use again the sample data for the city of Porto Alegre (Brazil) that comes with the `{r5r}` package.\n\n<!-- package logos side by side  -->\n<div style=\"text-align: center\">\n<table><tr><td><img src='/images/r5r_logo.png' width=\"180\"></td><td><img src='/images/accessibility_logo.png' width=\"180\"></td></tr></table>\n</div>\n\n\nThis flexible approach to calculate accessibility only involves 3 steps:\n\n1. Build a routable transport network\n2. Calculate a travel time matrix\n3. Calculate accessibility\n\nNow let's start loading the packages we need:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# allocating memory to java\noptions(java.parameters = \"-Xmx6G\")\n\nlibrary(r5r)\nlibrary(accessibility)\nlibrary(h3jsr)\nlibrary(dplyr)\nlibrary(mapview)\nlibrary(ggplot2)\n```\n:::\n\n\n\n\n\n# 1. Building a routable transport network\n\nFirst, we build the multimodal transport network by passing the path of our data directory to the `r5r::setup_r5()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# path to data directory\ndata_path <- system.file(\"extdata/poa\", package = \"r5r\")\n\n# build network\nr5r_core <- r5r::setup_r5(data_path, \n                          verbose = FALSE)\n```\n:::\n\n\n\n\n# 2. Calculate a travel time matrix\n\nThe second step is to calculate a travel time matrix with door-to-door travel time estimates from all origins to all destinations. To do this, we use the `r5r::travel_time_matrix()` function.\n\nAs basic inputs, this function receives the routable network created above, origin and destination points as `data.frames` with columns `id`, `lon` and `lat`, the transportation mode and the departure time.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read points data\npoints <- read.csv(file.path(data_path, \"poa_hexgrid.csv\"))\n\n# routing inputs\nmode <- c(\"walk\", \"transit\")\nmax_trip_duration <- 30                                         # <1>\ndeparture_datetime <- as.POSIXct(\"13-05-2019 14:00:00\",\n                                 format = \"%d-%m-%Y %H:%M:%S\")\n\n# calculate travel time matrix\nttm <- r5r::travel_time_matrix(\n  r5r_core = r5r_core,\n  origins = points,\n  destinations = points,\n  mode = mode,\n  departure_datetime = departure_datetime,\n  max_trip_duration = max_trip_duration,\n  progress = TRUE\n  )\n```\n:::\n\n\n\n1. In minutes\n\n\n::: {.callout-tip}\n## Tip\nNote that the `r5r::travel_time_matrix()` includes several additional parameters, which allows you to specify some trip characteristics, such as maximum walking time, a departure time window, the maximum number of public transport legs allowed, etc. For more info, check the documentation of the function by calling `?r5r::travel_time_matrix` in your R Console or check the documentation on [{r5r} website](https://ipeagit.github.io/r5r/reference/travel_time_matrix.html).\n:::\n\nThe output is a `data.frame`, which looks like this. It is a matrix in long format with the columns `from_id`, `to_id` and a third column indicating the travel time (in minutes) for each origin-destination pair.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           from_id           to_id travel_time_p50\n            <char>          <char>           <int>\n1: 89a901291abffff 89a901291abffff               1\n2: 89a901291abffff 89a90129157ffff              25\n3: 89a901291abffff 89a9012956bffff              29\n4: 89a901291abffff 89a90128257ffff              29\n5: 89a901291abffff 89a90129ed3ffff              29\n6: 89a901291abffff 89a9012913bffff              19\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n## Processing speed\n\nThe `travel_time_matrix()` function uses an extension of the RAPTOR routing algorithm [@conway2017evidencebased], making R5 extremely fast. Depending on the number of origin-destination pairs, `{r5r}` can calculate travel time matrices between 6 and 200 times faster than other multimodal routing softwares [@higgins2022calculating].\n:::\n\n\n# 3. Calculate accessibility \n\n<img align=\"right\" src=\"/images/accessibility_logo.png\" alt=\"logo\" width=\"140\"> \n\nHaving computed a travel time matrix, we can combine it with land use data to calculate accessibility. For this, we will use the `{accessibility}` package, which provides some fast and convenient functions to calculate several accessibility measures. \n\nThe package currently includes more than 7 different types of accessibility measures (see details in the package [documentation website](https://ipeagit.github.io/accessibility/reference/cost_to_closest.html)).\n\n- `cost_to_closest()`: Minimum travel cost to closest N number of opportunities\n- `cumulative_cutoff()`: Cumulative access based on a travel cost *cutoff*\n- `cumulative_interval()`: Cumulative access based on a travel time *interval*\n- `gravity()`: Gravity-based accessibility measures\n- `floating_catchment_area()`: Floating catchment area accessibility\n- `spatial_availability()`: Spatial availability\n- `balancing_cost()`: Balancing cost accessibility measure\n\nAs basic inputs, all functions of the package require a pre-calculated cost matrix (in our case, a travel time matrix) and some land use data with the number of opportunities (e.g. schools, jobs) in each cell of the study area. Both inputs must be organized in a `data.frame` format. We have just seen above the structure of the travel matrix. The land use `data.frame` must be organized like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# land use data\nhead(points)                # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               id       lon       lat population schools jobs healthcare\n1 89a901291abffff -51.15825 -30.05385          0       0 1214          0\n2 89a9012a3cfffff -51.21187 -30.10058        159       0    0          0\n3 89a901295b7ffff -51.16521 -30.07544       1008       0    3          1\n4 89a901284a3ffff -51.20535 -30.09005         92       0    0          0\n5 89a9012809bffff -51.19575 -30.07839        577       0    9          0\n6 89a901285cfffff -51.21108 -30.08124       1170       0  427          0\n```\n\n\n:::\n:::\n\n\n\n1. The land use data must contain an `id` column, referring to the ids listed in the travel matrix, and the number of opportunities in each location.\n\n\nNow let's calculate a few accessibility indicators.\n\n\n## 3.1 Cumulative accessibility measure\n\n### Threshold-based cumulative accessibility\n\nTo calculate a traditional cumulative accessibility measure, we can use the `accessibility::cumulative_cutoff()` function. Along with the travel matrix and land use datasets, we only need to pass the name of the column with the travel time values, the name of the column with the count of opportunities, and a travel time cutoff. \n\nHere, we calculate the number of schools accessible in 20 minutes.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# threshold-based cumulative accessibility\naccess_cum_t <- accessibility::cumulative_cutoff(\n  travel_matrix = ttm, \n  land_use_data = points,\n  travel_cost = 'travel_time_p50',\n  opportunity = 'schools',\n  cutoff = 20\n  )\n  \nhead(access_cum_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                id schools\n            <char>   <int>\n1: 89a9012124fffff       1\n2: 89a9012126bffff       3\n3: 89a9012127bffff       3\n4: 89a90128003ffff       8\n5: 89a90128007ffff       6\n6: 89a9012800bffff       9\n```\n\n\n:::\n:::\n\n\n\n### Interval-based cumulative accessibility\n\nPrevious studies have shown that the *ad-hoc* choice of a single travel time threshold can substantially influence the results of traditional cumulative accessibility measures, introducing bias into transport project evaluations and equity analyses. [@pereira2019future]. To overcome this issue, we have proposed a *time interval* cumulative accessibility measure [@tomasiello2023time]. This new metric estimates the average (or the median) number of opportunities that can be reached considering multiple minute-by-minute cutoffs within a given travel time interval. \n\nThe main advantage of this metric is that it mitigates the impacts of arbitrary choices of trip duration on accessibility analysis while preserving the computation and communicability advantages of threshold-based cumulative measures. \n\nHere, we calculate the average number of schools that can be reached between 20 and 30 minutes.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# interval-based cumulative accessibility\naccess_cum_i <- accessibility::cumulative_interval(\n  travel_matrix = ttm, \n  land_use_data = points,\n  travel_cost = 'travel_time_p50',\n  opportunity = 'schools',\n  interval = c(20,30),\n  summary_function = mean\n  )\n  \nhead(access_cum_i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                id schools\n            <char>   <int>\n1: 89a901291abffff      10\n2: 89a9012a3cfffff       0\n3: 89a901295b7ffff       9\n4: 89a901284a3ffff       1\n5: 89a9012809bffff      15\n6: 89a901285cfffff      55\n```\n\n\n:::\n:::\n\n\n\n\n\n<!-- \n::: {.callout-tip}\n## Active Vs Passive accessibility\n\nBy default, most functions of `{accessibility}` calculate *active* accessibility, i.e. some weighted count of opportunities that can be reached when *departing* from a given location. By setting the parater `active = FALSE`, you can calculate the catchment area (aka passive accessibility) of a given location, i.e. the number of people that could *arrive*.....\n:::\n -->\n\n\n\n## 3.2 Gravity-based accessibility measures\n\nThe package also includes `accessibility::gravity()` to calculate gravity-based accessibility metrics in a very flexible way.\n\nIt includes a `decay_function` parameter that can receive any *function* to convert travel cost into an impedance factor used to weight opportunities. For convenience, the package currently includes the following functions:\n\n- `decay_binary()`\n- `decay_exponential()`\n- `decay_linear()`\n- `decay_logistic()`\n- `decay_power()`\n- `decay_stepped()`\n\nLet's see a couple examples with logistic and negative exponential decay functions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# logistic decay\naccess_lgst <- gravity(\n  travel_matrix = ttm,\n  land_use_data = points,\n  decay_function = decay_logistic(cutoff = 15, sd = 5),\n  opportunity = \"schools\",\n  travel_cost = \"travel_time_p50\"\n)\n\n# negative exponential decay\naccess_nexp <- gravity(\n  travel_matrix = ttm,\n  land_use_data = points,\n  decay_function = decay_exponential(decay_value = 0.1),\n  opportunity = \"schools\",\n  travel_cost = \"travel_time_p50\"\n)\n```\n:::\n\n\n\n\nHere's a quick visulization of the shape of the decay curves we've used.\n\n\n\n\n::: {.cell code-show='false'}\n\n```{.r .cell-code  code-fold=\"true\"}\nnegative_exp <- decay_exponential(decay_value = 0.1)\nlogistic <- decay_logistic(cutoff = 15, sd = 5)\n\ntravel_costs <- seq(0, 30, 0.1)\n\nweights <- data.frame(\n  minutes = travel_costs,\n  negative_exp = negative_exp(travel_costs)[[\"0.1\"]],\n  logistic = logistic(travel_costs)[[\"c15;sd5\"]]\n)\n\n# reshape data to long format\nweights <- tidyr::pivot_longer(\n  weights,\n  cols = c('negative_exp',  'logistic'),\n  names_to = \"decay_function\",\n  values_to = \"weights\"\n)\n\nggplot(weights) +\n  geom_line(aes(minutes, weights, color = decay_function),\n            show.legend = FALSE) +\n  facet_wrap(. ~ decay_function, ncol = 2) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](3.2_flexible_approach_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n# 5. Accessibility map\n\nNow it is super simple to merge all of these accessibility estimates to our spatial grid to visualize these results on a map.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rbind all accessibility results in a single data.frame\naccess_cum_t$metric <- 'cum_threshold'\naccess_cum_i$metric <- 'cum_interval'\naccess_lgst$metric <- 'grav_logistic'\naccess_nexp$metric <- 'grav_exponential'\n\ndf <- rbind(access_cum_t,\n            access_cum_i,\n            access_lgst,\n            access_nexp)\n\n# retrieve polygons of H3 spatial grid\ngrid <- h3jsr::cell_to_polygon(points$id, simple = FALSE)\n\n# merge accessibility estimates\naccess_sf <- left_join(grid, df, by = c('h3_address'='id'))\n```\n:::\n\n\n\n\n\nPlot map\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = access_sf, aes(fill = schools), color= NA) +\n  scale_fill_viridis_c(direction = -1, option = 'B') +\n  labs(fill = \"Access\\nscore\") +\n  theme_minimal() +\n  theme(axis.title = element_blank()) +\n  facet_wrap(~metric) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](3.2_flexible_approach_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "3.2_flexible_approach_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}